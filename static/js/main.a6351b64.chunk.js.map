{"version":3,"sources":["store/actions.js","helpers/gridFinder.js","helpers/gridMove.js","helpers/gridGenerator.js","store/reducers.js","components/Status/Status.js","components/Puzzle/Puzzle.js","components/Winner/Winner.js","components/Puzzles/Puzzles.js","components/NewGame/NewGame.js","components/App/App.js","store/localStorage.js","index.js"],"names":["ACTION_MOVE","ACTION_NEW_GAME","doMove","from","type","payload","doNewGame","coordsCompare","one","two","getPossibleCoordsToMove","fromCoord","row","col","filter","coords","coord","rMax","cMax","isCoordPossibleToMove","isEmptyCoordPossibleToMove","emptyCoord","res","isRightCoordPosition","value","findIndexByCoord","grid","findIndex","item","getMovedGrid","toCoord","fromPosition","toPosition","gridNew","slice","map","Object","assign","tmp","generateGrid","min","max","plain","Array","fill","_","i","r","c","splice","length","Math","floor","random","done","push","generateGridState","state","win","initialState","started","moves","rootReducer","action","find","gridDone","Status","className","this","props","React","Component","connect","Puzzle","style","top","left","join","onClick","Winner","id","Puzzles","getState","assistant","getStateForAssistant","createAssistant","on","event","dispatchAssistantAction","select_coord","puzzles","item_selector","items","onPuzzleClick","onNewGame","close","puzzleArray","index","dispatch","bindActionCreators","NewGame","onNewGameClick","App","STORAGE_KEY","persistedState","serializedState","localStorage","getItem","JSON","parse","e","loadState","store","createStore","subscribe","removeItem","clearState","stringify","setItem","saveState","ReactDOM","render","document","getElementById"],"mappings":"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","file":"static/js/main.a6351b64.chunk.js","sourcesContent":["// Определяем действия\n\n// Тип действия \"Перемещение\"\nexport const ACTION_MOVE = 'ACTION_MOVE';\n// Тип действия \"Новая игра\"\nexport const ACTION_NEW_GAME = 'ACTION_NEW_GAME';\n\n// Действие \"Перемещение\"\nexport const doMove = (from) => {\n    return {\n        type: ACTION_MOVE,\n        payload: from       // Координаты перемещаемого элемента\n    };\n};\n\n// Действие \"Новая игра\"\nexport const doNewGame = () => {\n    return {\n        type: ACTION_NEW_GAME,\n        payload: null\n    };\n};\n","// Получить признак равенства координат\nexport const coordsCompare = (one, two) => {\n    return one[0] === two[0]\n        && one[1] === two[1];\n};\n\n// Получить признак того, что заданные координаты находятся в пределах нашей сетки\nexport const isCoordPossibleToMove = (coord, rMax = 4, cMax = 4) => {\n    return coord[0] >= 0 && coord[0] < rMax\n        && coord[1] >= 0 && coord[1] < cMax;\n}\n\n// Получить список координат с возможными перемещениями элемента в пределах нашей сетки\nexport const getPossibleCoordsToMove = (fromCoord) => {\n    // Исходные координаты элемента\n    let row = fromCoord[0];\n    let col = fromCoord[1];\n\n    // Возможные перемещения: вверх, вниз, влево, вправо; фильтруем по границам сетки...\n    return [\n        [row - 1, col],\n        [row + 1, col],\n        [row, col - 1],\n        [row, col + 1]\n    ].filter((coords) => isCoordPossibleToMove(coords)); // фильтруем по границам сетки... \n};\n\n// Проверить возможность перемещения элемента на место пустого элемента\nexport const isEmptyCoordPossibleToMove = (fromCoord, emptyCoord) => {\n    // Проверяем: есть ли в списке возможных перемещений координаты \"пустого\" элемента\n    let res = getPossibleCoordsToMove(fromCoord).filter(coord => coordsCompare(coord, emptyCoord));\n\n    // Если такой элемент есть, то true, иначе false\n    return res && res[0] ? true : false;\n};\n\n// Получить признак нахождения элемента в правильной позиции\nexport const isRightCoordPosition = (coord, value, rMax = 4, cMax = 4) => {\n    // Правильная позиция для элемента с номером \"0\" - это [3, 3]\n    if (!value) {\n        return coord[0] === rMax - 1 && coord[1] === cMax - 1;\n    }\n\n    // Правильная позиция для остальных соответствут индексу элемента в массиве + 1\n    return value === (coord[0] * cMax + coord[1] + 1);\n}\n\n// Получить номер элемента сетки (объекта в массиве) по заданным координатам\nexport const findIndexByCoord = (grid, coord) => {\n    return grid.findIndex(item => coordsCompare(item.coord, coord));\n};\n\n// Получить массив элементов вокруг заданного\nexport const getElementsAround = (grid, select_coord) => {\n    return getPossibleCoordsToMove(select_coord).map(coord => {\n        return grid[findIndexByCoord(grid, coord)];\n    });\n}\n","import { findIndexByCoord } from './gridFinder';\n\n// Переместить элемент из fromCoord в toCoord\nexport const getMovedGrid = (grid, fromCoord, toCoord) => {\n    // Получаем интекс перемещаемого элемента\n    let fromPosition = findIndexByCoord(grid, fromCoord);\n\n    // Получаем индекс: куда будем перемещать\n    let toPosition = findIndexByCoord(grid, toCoord);\n\n    // Проверяем: если вдруг вышли на пределы массива, то выходим...\n    if (fromPosition === -1 || toPosition === -1) {\n        return;\n    }\n\n    // Создаем копию массива (копируя свойства каждого объекта)\n    let gridNew = grid.slice(0).map(item => Object.assign({}, item));\n\n    // Меняем местами элементы\n    let tmp = gridNew[fromPosition].coord.slice(0);\n    gridNew[fromPosition].coord = gridNew[toPosition].coord.slice(0);\n    gridNew[toPosition].coord = tmp;\n\n    return gridNew;\n};\n","import { isRightCoordPosition } from './gridFinder';\n\n// Получить целое число в заданом диапазоне\nfunction getRandomInt(min, max) {\n    return Math.floor(Math.random() * (max - min)) + min;\n}\n\n// Генерация сетки\nconst generateGrid = (rMax, cMax) => {\n    // Общее количество элементов\n    let size = rMax * cMax;\n\n    // Массив индексов по порядку\n    let plain = (new Array(size)).fill(0).map((_, i) => i);\n\n    // Сетка с параметрами и значением элемента, который в этой ячейки сетки находится\n    let grid = [];\n\n    // Заполняем сетку параметрами и значениями\n    for (let r = 0; r < rMax; r++) {\n        for (let c = 0; c < cMax; c++) {\n            // Объект, опеределяющий элемент сетки\n            let item = {\n                coord: [r, c], // Координаты элемента сетки\n                value: plain.splice(getRandomInt(0, plain.length), 1)[0], // Для получения значения вырезаем случайный элемент из массива индексов\n            };\n\n            // Признак нахождения элемента в правильной позиции\n            item.done = isRightCoordPosition(item.coord, item.value);\n\n            // Добавляем элемент в сетку\n            grid.push(item);\n        }\n    }\n\n    return grid;\n};\n\n// Генерация полей объекта состояния приложения, определяющих данные сетки\nconst generateGridState = (rMax = 4, cMax = 4) => {\n    let state = {};\n\n    // grid - Сетка с параметрами и значением элемента, который в этой ячейки сетки находится\n    state.grid = generateGrid(rMax, cMax);\n\n    // Признак \"Победа!\" - когда все элементы находятся в правильной позиции\n    state.win = state.grid.filter(item => item.done).length === state.grid.length;\n\n    return state;\n};\n\nexport default generateGridState;\n","\nimport { ACTION_MOVE, ACTION_NEW_GAME } from './actions';\nimport { isEmptyCoordPossibleToMove, isRightCoordPosition } from './../helpers/gridFinder';\nimport { getMovedGrid } from './../helpers/gridMove';\nimport generateGridState from './../helpers/gridGenerator';\n\n// Исходное состояние\nconst initialState = {\n    started: false,         // Признак начала игры\n    moves: 0,               // Количество ходов\n    ...generateGridState()  // Состояние и параметры сетки\n};\n\n// Редуктор (функция обработки действий...)\nconst rootReducer = (state = initialState, action) => {\n    // По типу действия\n    switch (action.type) {\n        case ACTION_MOVE:   // Если действие определяет перемещение\n            \n            // Координаты перемещаемого элемента\n            let fromCoord = action.payload;\n\n            // Координаты \"пустого\" элемента (элемент с номером \"0\") \n            let toCoord = state.grid.find(item => !item.value).coord;\n\n            // Если возможно перемещение выбранного элемента на место пустого элемента, то выполнить такое перемещение\n            let grid = isEmptyCoordPossibleToMove(fromCoord, toCoord) && getMovedGrid(state.grid, fromCoord, toCoord);\n\n            // Если перемещение оказалось невозможным, то возвращаем неизменное состояние\n            if (!grid) {\n                return state;\n            }\n\n            // Обновляем признак правильной позиции для каждого элемента сетки\n            grid = grid.map(item => {\n                item.done = isRightCoordPosition(item.coord, item.value);\n                return item;\n            });\n\n            // Выбираем элементы, которые находятся в правильной позиции\n            let gridDone = grid.filter(item => item.done);\n\n            return {\n                ...state,\n                started: true,                          // Признак начала игры\n                win: gridDone.length === grid.length,   // Если количество элементов в сетки равно количеству элементов в правильных позициях (т.е. все на своих местах), то победа!\n                moves: state.moves + 1,                 // Инкремент счетчика ходов\n                grid: grid                              // Новая сетка, с учетом выполненного перемещения\n            };\n\n        case ACTION_NEW_GAME: // Если действие определяет переход в состояние \"Новая игра\"\n            return {...initialState,\n                    ...generateGridState()};\n\n        default:    // Если другой тип действия, то состояние приложения не изменяется\n            return state;\n    }\n};\n\nexport default rootReducer;","import React from 'react';\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport { doNewGame} from './../../store/actions';\nimport './Status.css';\n\nclass Status extends React.Component {\n    render() {\n        return (\n            <div className=\"status-top\">\n                <span className=\"status-text\">\n                    <i>Количество ходов: {this.props.moves}</i>\n                </span>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => ({\n    moves: state.moves\n});\n\nexport default connect(mapStateToProps)(Status);\n","import React from 'react';\nimport './Puzzle.css';\n\n// Один пазл\nclass Puzzle extends React.Component {\n    render() {\n        // Создаем стиль элемента...       \n        let style = {\n            top: this.props.coord[0] * 25 + '%',\n            left: this.props.coord[1] * 25 + '%'\n        };\n    \n        // Добавляем классы стилей...\n        let className = ['puzzle'];\n        if (!this.props.value) {\n            className.push('puzzle-empty');\n        }\n\n        // Добавляем классы стилей...\n        if (this.props.done) {\n            className.push('puzzle-done');\n        }\n    \n        return (\n            <div className={className.join(' ')}\n                 style={style}\n                 onClick={this.props.onClick}>\n                <span className=\"puzzle-inner noselect\">{this.props.value || ''}</span>\n            </div>\n        );\n    }\n}\n\nexport default Puzzle;\n","import React from 'react';\nimport { connect } from 'react-redux'\nimport './Winner.css';\n\n// Элемент для отображения состояния \"Победа!\"\nclass Winner extends React.Component {\n    render() {\n        if (!this.props.win) \n            return null;\n        else\n            return (\n                <div id=\"winner\">\n                    <span>Победа!</span>\n                </div>\n            );\n    }\n}\n\nconst mapStateToProps = (state) => (\n    { win: state.win }\n);\n\nexport default connect(mapStateToProps)(Winner);\n","import React from 'react';\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport { doMove, doNewGame } from './../../store/actions';\nimport Puzzle from './../Puzzle/Puzzle';\nimport Winner from './../Winner/Winner';\nimport { getElementsAround } from './../../helpers/gridFinder';\nimport { createSmartappDebugger, createAssistant } from \"@sberdevices/assistant-client\";\nimport './Puzzles.css';\n\n// Инициализация асистента\nconst initializeAssistant = (getState) => {\n    // console.log('NODE_ENV =', process.env.NODE_ENV);\n\n    if (process.env.NODE_ENV === \"development\") {\n      return createSmartappDebugger({\n        token: process.env.REACT_APP_TOKEN ?? \"\",\n        initPhrase: `Запусти ${process.env.REACT_APP_SMARTAPP}`,\n        getState,\n      });\n    }\n    return createAssistant({ getState });\n};\n\n// Пазлы: контейнер, в который помещаем 15 пазлов\nclass Puzzles extends React.Component {\n\n    constructor(props) {\n        super(props);\n    \n        // Инициализируем асистента\n        this.assistant = initializeAssistant( () => this.getStateForAssistant() );\n\n        // Регистрируем событие для onData\n        this.assistant.on(\"data\", (event) => {\n            // console.log(`assistant.on(data)`, event);\n            const { action } = event\n            this.dispatchAssistantAction(action);\n        });\n\n        // Регистрируем событие для onStart\n        this.assistant.on(\"start\", (event) => {\n            // console.log(`assistant.on(start)`, event);\n        });   \n    }\n    \n    // Получить состояние для передачи ассистенту\n    getStateForAssistant () {\n        // console.log('getStateForAssistant: puzzles:', this.props.puzzles)\n\n        // Координаты \"пустого\" элемента (элемент с номером \"0\") \n        let coord = this.props.puzzles.find(item => !item.value).coord;\n\n        // Получить массив индексов элементов вокруг заданного\n        const stateAssist = {\n            item_selector: {\n                items: getElementsAround(this.props.puzzles, coord)\n          }\n        };\n\n        // console.log('getStateForAssistant: stateAssist:', stateAssist)\n        return stateAssist;\n    }\n    \n    // Обработка действий, полученных от ассистента\n    dispatchAssistantAction (action) {\n        if (action) {\n            switch (action.type) {\n                case 'on_click_puzzle':\n                    action.item && this.props.onPuzzleClick(action.item.coord)\n                    return;\n                        \n                case 'reset_game':\n                    this.props.onNewGame();\n                    return;\n\n                case 'close_game':\n                    this.assistant.close();\n                    return;\n                        \n                default:\n                    return;                    \n            }\n        }\n    }\n\n    render() {\n        // Создаем массив...\n        let puzzleArray = this.props.puzzles.map((item, index) => {\n            return (\n                <Puzzle\n                    key={'item:' + index}\n                    {...item}\n                    onClick={() => item.value && this.props.onPuzzleClick(item.coord)}\n                />\n            );\n        });\n        \n        // Добавляем массив в контейнер + элемент \"Победа!\"...\n        return (\n            <div className=\"puzzles-wrapper\">\n                <div className=\"puzzles\">\n                    {puzzleArray}\n                </div>\n                <Winner/>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => ({\n    puzzles: state.grid\n});\n\nconst mapActionsToProps = (dispatch) => ({\n    onPuzzleClick: bindActionCreators(doMove, dispatch),\n    onNewGame: bindActionCreators(doNewGame, dispatch)\n});\n\nexport default connect(mapStateToProps, mapActionsToProps)(Puzzles);\n","import React from 'react';\nimport { bindActionCreators } from 'redux'\nimport { connect } from 'react-redux'\nimport { doNewGame} from './../../store/actions';\nimport './NewGame.css';\n\nclass NewGame extends React.Component {\n    render() {\n        return (\n            <div className=\"status-down\">\n                <button\n                    className=\"status-button\"\n                    onClick={() => {this.props.onNewGameClick()}}\n                ><i>Новая игра</i></button>\n            </div>\n        );\n    }\n}\n\nconst mapStateToProps = (state) => ({});\n\nconst mapActionsToProps = (dispatch) => ({\n    onNewGameClick: bindActionCreators(doNewGame, dispatch)\n});\n\nexport default connect(mapStateToProps, mapActionsToProps)(NewGame);\n","import React from 'react';\nimport Status from '../Status/Status';\nimport Puzzles from './../Puzzles/Puzzles';\nimport NewGame from './../NewGame/NewGame';\nimport './App.css';\n\nclass App extends React.Component {\n    render() {\n        return (\n            <div className=\"app\">\n                <div className=\"container\">\n                    <Status/>\n                    <Puzzles/>\n                    <NewGame/>\n                </div>\n            </div>\n        );\n    }\n}\n\nexport default App;\n","// Ключ, с которым сохраняется состояние приложения в localStorage\nconst STORAGE_KEY = 'fifteenpuzzle:state';\n\n// Загрузить состояние приложения из localStorage\nexport const loadState = () => {\n    try {\n        const serializedState = localStorage.getItem(STORAGE_KEY);\n        if (serializedState === null) {\n            return;\n        }\n\n        return JSON.parse(serializedState);\n    } catch (e) {\n        return;\n    }\n};\n\n// Сохранить состояние приложения в localStorage\nexport const saveState = (state) => {\n    try {\n        const serializedState = JSON.stringify(state);\n\n        localStorage.setItem(STORAGE_KEY, serializedState);\n    } catch (e) {}\n};\n\n// Удалить состояние приложения из localStorage\nexport const clearState = () => {\n    try {\n        localStorage.removeItem(STORAGE_KEY);\n    } catch (e) {}\n};\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport { createStore } from 'redux';\nimport { Provider } from 'react-redux';\nimport rootReducer from './store/reducers';\nimport App from './components/App/App';\nimport { loadState, saveState, clearState } from './store/localStorage';\nimport './index.css';\n\n// Загружаем состояние приложения из localStorage (localStorage - локальное хранилище)\nconst persistedState = loadState();\n\n// Создаем хранилище состояния приложения\nconst store = createStore(rootReducer, persistedState);\n\n// Регистрируем обработчик на изменение состояния приложения\nstore.subscribe(() => {\n    const state = store.getState(); // Получаем текущее состояние\n\n    // Если установлен признак победы или еще не было ни одного перемещения\n    if (state.win || !state.started) {\n        clearState();       // Удаляем состояние приложения из localStorage\n    } else {\n        saveState(state);   // Сохраняем состояние приложения в localStorage\n    }\n});\n\nReactDOM.render(\n    <Provider store={store}>\n        <App/>\n    </Provider>,\n    document.getElementById('root')\n)\n"],"sourceRoot":""}